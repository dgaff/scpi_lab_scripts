#!/usr/bin/env python3
"""
Waveform Generator for Keysight Instruments
A GUI tool to generate custom waveforms and export as CSV files

Note: this was generated by Claude through multiple iterations. It's not 100% working yet. Some issues

1. The drawn plot does not redraw when you stop dragging the mouse.
2. The drawn plot isn't great about picking up where you left off if you don't click it exactly. I'd prefer it pick up where you left off.
3. Changing the number of samples on the drawn plot mostly works, but it you reduce the samples, it truncates the waveform but doesn't readjust the time axis.
Seems to be related to the fact that the red drawn line doesn't correctly update to blue after you let up.
4. Probably worth integrating directly into the arv_waveform.py script to send this straight to the function generator.
5. The input fields are too sensitive. It doesn't wait for you to stop typing before it tries to redo the math. It also doesn't reformat the field, e.g. leading zero.
6. Probably should save the fields between sessions.
7. I'm not sure what the generate button does, since just changing a parameter automatically generates a waveform.
8. The info area at the bottom should move to the top right area so there's more room for the plots.
9. Some input fields aren't relevant in a drawn waveform.

"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import csv
import math
from matplotlib.ticker import FuncFormatter

class WaveformGenerator:
    def __init__(self, root):
        self.root = root
        self.root.title("Waveform Generator for Keysight")
        self.root.geometry("1500x850")
        
        # Current waveform data
        self.time_data = None
        self.amplitude_data = None
        self.sample_rate = 1000000  # Default 1 MHz
        
        # Drawing state
        self.drawing_points = []  # List of (time, amplitude) tuples
        self.is_drawing = False
        self.drawn_waveform_data = None
        
        # UI state
        self.show_fft = tk.BooleanVar(value=False)
        
        # Initialize plot objects
        self.fig = None
        self.canvas = None
        self.ax1 = None
        self.ax2 = None
        
        self.setup_ui()

    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Control panel - more compact layout
        control_frame = ttk.LabelFrame(main_frame, text="Waveform Parameters", padding="5")
        control_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 5))
        
        # Row 1: Type, Frequency, Amplitude, DC Offset
        ttk.Label(control_frame, text="Type:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        self.waveform_type = tk.StringVar(value="sine")
        waveform_combo = ttk.Combobox(control_frame, textvariable=self.waveform_type, 
                                    values=["sine", "square", "triangle", "sawtooth", "noise", "custom", "drawn"], 
                                    width=10, state="readonly")
        waveform_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 15))
        waveform_combo.bind('<<ComboboxSelected>>', lambda e: self.on_waveform_type_change())
        
        ttk.Label(control_frame, text="Freq (Hz):").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        self.frequency = tk.StringVar(value="1000")
        freq_entry = ttk.Entry(control_frame, textvariable=self.frequency, width=10, font=('TkDefaultFont', 9))
        freq_entry.grid(row=0, column=3, sticky=tk.W, padx=(0, 15))
        freq_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Amp (V):").grid(row=0, column=4, sticky=tk.W, padx=(0, 5))
        self.amplitude = tk.StringVar(value="1.0")
        amp_entry = ttk.Entry(control_frame, textvariable=self.amplitude, width=8, font=('TkDefaultFont', 9))
        amp_entry.grid(row=0, column=5, sticky=tk.W, padx=(0, 15))
        amp_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Offset (V):").grid(row=0, column=6, sticky=tk.W, padx=(0, 5))
        self.dc_offset = tk.StringVar(value="0.0")
        offset_entry = ttk.Entry(control_frame, textvariable=self.dc_offset, width=8, font=('TkDefaultFont', 9))
        offset_entry.grid(row=0, column=7, sticky=tk.W, padx=(0, 15))
        offset_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        # Row 2: Duration, Sample Rate, Samples, Duty Cycle
        ttk.Label(control_frame, text="Duration (ms):").grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.duration = tk.StringVar(value="10")
        dur_entry = ttk.Entry(control_frame, textvariable=self.duration, width=10, font=('TkDefaultFont', 9))
        dur_entry.grid(row=1, column=1, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        dur_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Sample Rate:").grid(row=1, column=2, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.sample_rate_var = tk.StringVar(value="1000000")
        sr_entry = ttk.Entry(control_frame, textvariable=self.sample_rate_var, width=10, font=('TkDefaultFont', 9))
        sr_entry.grid(row=1, column=3, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        sr_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Samples:").grid(row=1, column=4, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.num_samples = tk.StringVar(value="10000")
        samples_entry = ttk.Entry(control_frame, textvariable=self.num_samples, width=8, font=('TkDefaultFont', 9))
        samples_entry.grid(row=1, column=5, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        samples_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Duty (%):").grid(row=1, column=6, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.duty_cycle = tk.StringVar(value="50")
        duty_entry = ttk.Entry(control_frame, textvariable=self.duty_cycle, width=8, font=('TkDefaultFont', 9))
        duty_entry.grid(row=1, column=7, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        duty_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        # Row 3: Buttons and FFT toggle
        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, columnspan=8, sticky=(tk.W, tk.E), pady=(5, 0))

        ttk.Button(button_frame, text="Generate", command=self.generate_waveform).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="Clear Drawing", command=self.clear_drawing).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="Export CSV", command=self.export_csv).pack(side=tk.LEFT, padx=(0, 20))
        
        # FFT toggle
        fft_checkbox = ttk.Checkbutton(button_frame, text="Show FFT", variable=self.show_fft, command=self.toggle_fft)
        fft_checkbox.pack(side=tk.LEFT)
        
        # Plot frame
        plot_frame = ttk.LabelFrame(main_frame, text="Waveform Preview", padding="5")
        plot_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Create matplotlib figure
        self.fig = plt.figure(figsize=(10, 6), dpi=80)
        
        # Embed plot in tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Connect mouse events for drawing
        self.canvas.mpl_connect('button_press_event', self.on_mouse_press)
        self.canvas.mpl_connect('motion_notify_event', self.on_mouse_move)
        self.canvas.mpl_connect('button_release_event', self.on_mouse_release)
        
        # Info frame - more compact
        info_frame = ttk.LabelFrame(main_frame, text="Info", padding="5")
        info_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))
        
        self.info_text = tk.Text(info_frame, height=3, wrap=tk.WORD, font=('TkDefaultFont', 9))
        scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=scrollbar.set)
        self.info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Schedule plot setup and waveform generation after the GUI is fully rendered
        self.root.after(50, self._initialize_plots)

    def _initialize_plots(self):
        """Initialize plots after the GUI is fully rendered"""
        self.setup_plots()
        self.generate_waveform()

    def setup_plots(self):
        """Setup plot layout based on FFT visibility"""
        self.fig.clear()
        if self.show_fft.get():
            self.ax1, self.ax2 = self.fig.subplots(2, 1)
        else:
            self.ax1 = self.fig.add_subplot(111)
            self.ax2 = None
        
        # Apply tight_layout AFTER the canvas has been properly sized
        self.fig.tight_layout(pad=1.5)
        
        # Force canvas to redraw
        if hasattr(self, 'canvas') and self.canvas:
            self.canvas.draw()

    def toggle_fft(self):
        """Toggle FFT plot visibility"""
        self.setup_plots()
        self.update_plot()

    def setup_ui_old(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        main_frame.rowconfigure(1, weight=1)
        
        # Control panel - more compact layout
        control_frame = ttk.LabelFrame(main_frame, text="Waveform Parameters", padding="5")
        control_frame.grid(row=0, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 5))
        
        # Row 1: Type, Frequency, Amplitude, DC Offset
        ttk.Label(control_frame, text="Type:").grid(row=0, column=0, sticky=tk.W, padx=(0, 5))
        self.waveform_type = tk.StringVar(value="sine")
        waveform_combo = ttk.Combobox(control_frame, textvariable=self.waveform_type, 
                                    values=["sine", "square", "triangle", "sawtooth", "noise", "custom", "drawn"], 
                                    width=10, state="readonly")
        waveform_combo.grid(row=0, column=1, sticky=tk.W, padx=(0, 15))
        waveform_combo.bind('<<ComboboxSelected>>', lambda e: self.on_waveform_type_change())
        
        ttk.Label(control_frame, text="Freq (Hz):").grid(row=0, column=2, sticky=tk.W, padx=(0, 5))
        self.frequency = tk.StringVar(value="1000")
        freq_entry = ttk.Entry(control_frame, textvariable=self.frequency, width=10, font=('TkDefaultFont', 9))
        freq_entry.grid(row=0, column=3, sticky=tk.W, padx=(0, 15))
        freq_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Amp (V):").grid(row=0, column=4, sticky=tk.W, padx=(0, 5))
        self.amplitude = tk.StringVar(value="1.0")
        amp_entry = ttk.Entry(control_frame, textvariable=self.amplitude, width=8, font=('TkDefaultFont', 9))
        amp_entry.grid(row=0, column=5, sticky=tk.W, padx=(0, 15))
        amp_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Offset (V):").grid(row=0, column=6, sticky=tk.W, padx=(0, 5))
        self.dc_offset = tk.StringVar(value="0.0")
        offset_entry = ttk.Entry(control_frame, textvariable=self.dc_offset, width=8, font=('TkDefaultFont', 9))
        offset_entry.grid(row=0, column=7, sticky=tk.W, padx=(0, 15))
        offset_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        # Row 2: Duration, Sample Rate, Samples, Duty Cycle
        ttk.Label(control_frame, text="Duration (ms):").grid(row=1, column=0, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.duration = tk.StringVar(value="10")
        dur_entry = ttk.Entry(control_frame, textvariable=self.duration, width=10, font=('TkDefaultFont', 9))
        dur_entry.grid(row=1, column=1, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        dur_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Sample Rate:").grid(row=1, column=2, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.sample_rate_var = tk.StringVar(value="1000000")
        sr_entry = ttk.Entry(control_frame, textvariable=self.sample_rate_var, width=10, font=('TkDefaultFont', 9))
        sr_entry.grid(row=1, column=3, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        sr_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Samples:").grid(row=1, column=4, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.num_samples = tk.StringVar(value="10000")
        samples_entry = ttk.Entry(control_frame, textvariable=self.num_samples, width=8, font=('TkDefaultFont', 9))
        samples_entry.grid(row=1, column=5, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        samples_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        ttk.Label(control_frame, text="Duty (%):").grid(row=1, column=6, sticky=tk.W, padx=(0, 5), pady=(5, 0))
        self.duty_cycle = tk.StringVar(value="50")
        duty_entry = ttk.Entry(control_frame, textvariable=self.duty_cycle, width=8, font=('TkDefaultFont', 9))
        duty_entry.grid(row=1, column=7, sticky=tk.W, padx=(0, 15), pady=(5, 0))
        duty_entry.bind('<KeyRelease>', lambda e: self.root.after(500, self.generate_waveform))
        
        # Row 3: Buttons and FFT toggle
        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, columnspan=8, sticky=(tk.W, tk.E), pady=(5, 0))
    
        ttk.Button(button_frame, text="Generate", command=self.generate_waveform).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="Clear Drawing", command=self.clear_drawing).pack(side=tk.LEFT, padx=(0, 10))
        ttk.Button(button_frame, text="Export CSV", command=self.export_csv).pack(side=tk.LEFT, padx=(0, 20))
        
        # FFT toggle
        fft_checkbox = ttk.Checkbutton(button_frame, text="Show FFT", variable=self.show_fft, command=self.toggle_fft)
        fft_checkbox.pack(side=tk.LEFT)
        
        # Plot frame
        plot_frame = ttk.LabelFrame(main_frame, text="Waveform Preview", padding="5")
        plot_frame.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Create matplotlib figure - dynamic subplots
        self.fig = plt.figure(figsize=(10, 6))
        self.setup_plots()
        
        # Embed plot in tkinter
        self.canvas = FigureCanvasTkAgg(self.fig, master=plot_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Connect mouse events for drawing
        self.canvas.mpl_connect('button_press_event', self.on_mouse_press)
        self.canvas.mpl_connect('motion_notify_event', self.on_mouse_move)
        self.canvas.mpl_connect('button_release_event', self.on_mouse_release)
        
        # Info frame - more compact
        info_frame = ttk.LabelFrame(main_frame, text="Info", padding="5")
        info_frame.grid(row=2, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))
        
        self.info_text = tk.Text(info_frame, height=3, wrap=tk.WORD, font=('TkDefaultFont', 9))
        scrollbar = ttk.Scrollbar(info_frame, orient=tk.VERTICAL, command=self.info_text.yview)
        self.info_text.configure(yscrollcommand=scrollbar.set)
        self.info_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Generate default waveform after UI is fully set up
        self.generate_waveform()
    
    def generate_waveform(self):
        try:
            # Get parameters
            freq = float(self.frequency.get())
            amp = float(self.amplitude.get())
            offset = float(self.dc_offset.get())
            duration_ms = float(self.duration.get())
            self.sample_rate = float(self.sample_rate_var.get())
            duty = float(self.duty_cycle.get()) / 100.0
            waveform = self.waveform_type.get()
            
            # Use samples if specified, otherwise calculate from duration and sample rate
            try:
                num_samples = int(self.num_samples.get())
                duration_s = num_samples / self.sample_rate
                # Update duration field to match
                self.duration.set(f"{duration_s * 1000:.3f}")
            except ValueError:
                # Fall back to duration-based calculation
                duration_s = duration_ms / 1000.0
                num_samples = int(self.sample_rate * duration_s)
                self.num_samples.set(str(num_samples))
            
            # Calculate time vector
            self.time_data = np.linspace(0, duration_s, num_samples)
            
            # Generate waveform based on type
            if waveform == "sine":
                self.amplitude_data = amp * np.sin(2 * np.pi * freq * self.time_data) + offset
            elif waveform == "square":
                # Improved square wave with duty cycle support
                period_samples = int(self.sample_rate / freq) if freq > 0 else num_samples
                square_wave = np.zeros(num_samples)
                for i in range(num_samples):
                    cycle_position = (i % period_samples) / period_samples
                    square_wave[i] = 1 if cycle_position < duty else -1
                self.amplitude_data = amp * square_wave + offset
            elif waveform == "triangle":
                self.amplitude_data = amp * (2/np.pi) * np.arcsin(np.sin(2 * np.pi * freq * self.time_data)) + offset
            elif waveform == "sawtooth":
                self.amplitude_data = amp * 2 * (freq * self.time_data - np.floor(0.5 + freq * self.time_data)) + offset
            elif waveform == "noise":
                np.random.seed(42)  # For reproducible noise
                self.amplitude_data = amp * np.random.normal(0, 1, len(self.time_data)) + offset
            elif waveform == "custom":
                # Example: combination of sine waves
                self.amplitude_data = (amp * 0.6 * np.sin(2 * np.pi * freq * self.time_data) + 
                                    amp * 0.3 * np.sin(2 * np.pi * freq * 3 * self.time_data) + 
                                    amp * 0.1 * np.sin(2 * np.pi * freq * 5 * self.time_data) + offset)
            elif waveform == "drawn":
                if self.drawn_waveform_data is not None:
                    old_len = len(self.drawn_waveform_data)
                    if num_samples > old_len:
                        # Extend with zeros (or offset) to match new length
                        extra = np.zeros(num_samples - old_len) + offset
                        self.amplitude_data = np.concatenate([self.drawn_waveform_data, extra])
                    else:
                        # Truncate if needed
                        self.amplitude_data = self.drawn_waveform_data[:num_samples].copy()
                    # Always update drawn_waveform_data to match new length
                    self.drawn_waveform_data = self.amplitude_data.copy()
                else:
                    # Initialize with zeros if no drawing exists
                    self.amplitude_data = np.zeros(len(self.time_data)) + offset
                    self.drawn_waveform_data = self.amplitude_data.copy()
            
            self.update_plot()
            self.update_info()
            
        except ValueError as e:
            messagebox.showerror("Error", f"Invalid parameter: {str(e)}")
        except Exception as e:
            messagebox.showerror("Error", f"Error generating waveform: {str(e)}")
    
    def update_plot(self):
        # Safety check - ensure canvas is initialized
        if self.canvas is None or self.ax1 is None:
            return
            
        # Clear previous plots
        self.ax1.clear()
        if self.ax2 is not None:
            self.ax2.clear()
        
        # Time domain plot
        if self.waveform_type.get() == "drawn":
            # For drawn waveform, show drawing area and current waveform
            self.ax1.plot(self.time_data * 1000, self.amplitude_data, 'b-', linewidth=2, alpha=0.8)
            
            # Draw current drawing points if any
            if self.drawing_points:
                times, amplitudes = zip(*self.drawing_points)
                self.ax1.plot([t * 1000 for t in times], amplitudes, 'ro-', markersize=2, linewidth=1, alpha=0.7)
            
            # Add drawing instruction
            # self.ax1.text(0.02, 0.98, 'Click and drag to draw waveform', 
            #              transform=self.ax1.transAxes, fontsize=9, 
            #              verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))
        else:
            self.ax1.plot(self.time_data * 1000, self.amplitude_data, 'b-', linewidth=1.5)
        
        self.ax1.set_xlabel('Time (ms)', fontsize=6)
        self.ax1.set_ylabel('Amplitude (V)', fontsize=6)
        self.ax1.set_title('Time Domain', fontsize=6)
        self.ax1.grid(True, alpha=0.3)
        self.ax1.tick_params(axis='both', which='major', labelsize=6)
        
        # Set consistent y-axis limits for drawing mode
        if self.waveform_type.get() == "drawn":
            try:
                amp = float(self.amplitude.get())
                offset = float(self.dc_offset.get())
                self.ax1.set_ylim(offset - amp * 1.5, offset + amp * 1.5)
            except ValueError:
                self.ax1.set_ylim(-2, 2)
        
        # Frequency domain plot (FFT) - only if enabled
        if self.show_fft.get() and self.ax2 is not None and len(self.amplitude_data) > 1:
            fft = np.fft.fft(self.amplitude_data)
            freqs = np.fft.fftfreq(len(fft), 1/self.sample_rate)
            # Only plot positive frequencies greater than zero
            positive_freqs = freqs[:len(freqs)//2]
            magnitude = np.abs(fft[:len(fft)//2])

            # Avoid log(0) by filtering out zero frequencies
            mask = positive_freqs > 0
            positive_freqs = positive_freqs[mask]
            magnitude = magnitude[mask]

            self.ax2.loglog(positive_freqs, magnitude, 'r-', linewidth=1.5)
            self.ax2.set_xlabel('Frequency (Hz)', fontsize=6)
            self.ax2.set_ylabel('Magnitude', fontsize=6)
            self.ax2.set_title('Frequency Domain (FFT)', fontsize=6)
            self.ax2.grid(True, which='both', axis='both', alpha=0.3)
            self.ax2.tick_params(axis='both', which='major', labelsize=6)

            # Set x-axis limits to nearest powers of 10
            try:
                max_freq = min(10 * float(self.frequency.get()), self.sample_rate/2)
            except ValueError:
                max_freq = self.sample_rate/10
            min_freq = max(positive_freqs[0], 1)  # Avoid log(0)
            self.ax2.set_xlim([10**np.floor(np.log10(min_freq)), 10**np.ceil(np.log10(max_freq))])

            # Format x-axis ticks as plain numbers (e.g., 100, 1,000, 10,000)
            def plain_number(x, pos):
                if x >= 1000:
                    return f"{int(x):,}"
                else:
                    return str(int(x))
            self.ax2.xaxis.set_major_formatter(FuncFormatter(plain_number))
        
        self.canvas.draw()

    def update_info(self):
        if self.time_data is not None and self.amplitude_data is not None:
            info = f"Samples: {len(self.amplitude_data)}\n"
            info += f"Duration: {self.time_data[-1]*1000:.3f} ms\n"
            info += f"Min Amplitude: {np.min(self.amplitude_data):.6f} V\n"
            info += f"Max Amplitude: {np.max(self.amplitude_data):.6f} V\n"
            info += f"RMS: {np.sqrt(np.mean(self.amplitude_data**2)):.6f} V\n"
            info += f"Peak-to-Peak: {np.ptp(self.amplitude_data):.6f} V"
            
            self.info_text.delete(1.0, tk.END)
            self.info_text.insert(1.0, info)
    
    def export_csv(self):
        if self.time_data is None or self.amplitude_data is None:
            messagebox.showerror("Error", "No waveform data to export")
            return
        
        filename = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save Waveform as CSV"
        )
        
        if filename:
            try:
                with open(filename, 'w', newline='') as csvfile:
                    writer = csv.writer(csvfile)
                    
                    # Write header with metadata
                    writer.writerow(['# Waveform Generator Output'])
                    writer.writerow([f'# Sample Rate: {self.sample_rate} Hz'])
                    writer.writerow([f'# Frequency: {self.frequency.get()} Hz'])
                    writer.writerow([f'# Amplitude: {self.amplitude.get()} V'])
                    writer.writerow([f'# DC Offset: {self.dc_offset.get()} V'])
                    writer.writerow([f'# Duration: {self.duration.get()} ms'])
                    writer.writerow([f'# Samples: {len(self.amplitude_data)}'])
                    writer.writerow(['# Time (s), Amplitude (V)'])
                    writer.writerow(['Time', 'Amplitude'])
                    
                    # Write data
                    for t, a in zip(self.time_data, self.amplitude_data):
                        writer.writerow([f'{t:.10f}', f'{a:.10f}'])
                
                messagebox.showinfo("Success", f"Waveform exported to {filename}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Error saving file: {str(e)}")
    
    def on_waveform_type_change(self):
        """Handle waveform type change"""
        if self.waveform_type.get() == "drawn":
            # Initialize time data for drawing mode
            try:
                duration_ms = float(self.duration.get())
                self.sample_rate = float(self.sample_rate_var.get())
                duration_s = duration_ms / 1000.0
                num_samples = int(self.sample_rate * duration_s)
                self.time_data = np.linspace(0, duration_s, num_samples)
                
                # Initialize with DC offset if no drawn data exists
                if self.drawn_waveform_data is None:
                    offset = float(self.dc_offset.get())
                    self.amplitude_data = np.zeros(len(self.time_data)) + offset
                    self.drawn_waveform_data = self.amplitude_data.copy()
                else:
                    self.amplitude_data = self.drawn_waveform_data.copy()
                
                self.update_plot()
                self.update_info()
            except ValueError:
                pass
        else:
            self.generate_waveform()
    
    def on_mouse_press(self, event):
        """Handle mouse press for drawing"""
        if (self.waveform_type.get() == "drawn" and 
            event.inaxes == self.ax1 and 
            event.button == 1):  # Left mouse button
            
            self.is_drawing = True
            self.drawing_points = []
            
            # Convert click to data coordinates
            time_val = event.xdata / 1000  # Convert from ms to seconds
            amplitude_val = event.ydata
            
            if time_val is not None and amplitude_val is not None:
                self.drawing_points.append((time_val, amplitude_val))
    
    def on_mouse_move(self, event):
        """Handle mouse movement for drawing"""
        if (self.is_drawing and 
            self.waveform_type.get() == "drawn" and 
            event.inaxes == self.ax1):
            
            time_val = event.xdata / 1000  # Convert from ms to seconds
            amplitude_val = event.ydata
            
            if time_val is not None and amplitude_val is not None:
                self.drawing_points.append((time_val, amplitude_val))
                
                # Update plot in real-time (but not too frequently)
                if len(self.drawing_points) % 5 == 0:  # Update every 5 points
                    self.interpolate_drawn_waveform()
                    self.update_plot()
    
    def on_mouse_release(self, event):
        """Handle mouse release for drawing"""
        if self.is_drawing and self.waveform_type.get() == "drawn":
            self.is_drawing = False
            
            if len(self.drawing_points) > 1:
                self.interpolate_drawn_waveform()
                self.update_plot()
                self.update_info()
            
                # # Force immediate canvas refresh
                # if hasattr(self, 'canvas'):
                #     self.canvas.draw()  # Use draw() instead of draw_idle()
                # elif hasattr(self, 'fig'):
                #     self.fig.canvas.draw()

    def interpolate_drawn_waveform_old(self):
        """Interpolate drawn points to match the time data"""
        if len(self.drawing_points) < 2 or self.time_data is None:
            return
        
        # Sort drawing points by time
        self.drawing_points.sort(key=lambda x: x[0])
        
        # Extract times and amplitudes
        draw_times, draw_amplitudes = zip(*self.drawing_points)
        draw_times = np.array(draw_times)
        draw_amplitudes = np.array(draw_amplitudes)
        
        # Clamp drawing times to valid range
        min_time = self.time_data[0]
        max_time = self.time_data[-1]
        draw_times = np.clip(draw_times, min_time, max_time)
        
        # Interpolate to match our time data
        interpolated = np.interp(self.time_data, draw_times, draw_amplitudes)
        
        # Blend with existing waveform (replace only the drawn region)
        if len(draw_times) > 0:
            start_idx = np.searchsorted(self.time_data, draw_times[0])
            end_idx = np.searchsorted(self.time_data, draw_times[-1]) + 1
            start_idx = max(0, start_idx)
            end_idx = min(len(self.amplitude_data), end_idx)
            
            self.amplitude_data[start_idx:end_idx] = interpolated[start_idx:end_idx]
            self.drawn_waveform_data = self.amplitude_data.copy()
    
    def interpolate_drawn_waveform(self):
        """Interpolate drawn points to match the time data"""
        if len(self.drawing_points) < 2 or self.time_data is None:
            return
        
        # Sort drawing points by time
        self.drawing_points.sort(key=lambda x: x[0])
        
        # Extract times and amplitudes
        draw_times, draw_amplitudes = zip(*self.drawing_points)
        draw_times = np.array(draw_times)
        draw_amplitudes = np.array(draw_amplitudes)
        
        # Clamp drawing times to valid range
        min_time = self.time_data[0]
        max_time = self.time_data[-1]
        draw_times = np.clip(draw_times, min_time, max_time)
        
        # Find the range of indices that need to be updated
        start_idx = np.searchsorted(self.time_data, draw_times[0])
        end_idx = np.searchsorted(self.time_data, draw_times[-1]) + 1
        start_idx = max(0, start_idx)
        end_idx = min(len(self.amplitude_data), end_idx)
        
        # Only interpolate for the specific time range that was drawn
        time_slice = self.time_data[start_idx:end_idx]
        
        if len(time_slice) > 0:
            # Interpolate only for the drawn region
            interpolated_slice = np.interp(time_slice, draw_times, draw_amplitudes)
            
            # Update only the drawn region
            self.amplitude_data[start_idx:end_idx] = interpolated_slice
            self.drawn_waveform_data = self.amplitude_data.copy()

    def clear_drawing(self):
        """Clear the drawn waveform"""
        if self.waveform_type.get() == "drawn":
            try:
                offset = float(self.dc_offset.get())
                if self.time_data is not None:
                    self.amplitude_data = np.zeros(len(self.time_data)) + offset
                    self.drawn_waveform_data = self.amplitude_data.copy()
                    self.drawing_points = []
                    self.update_plot()
                    self.update_info()
            except ValueError:
                pass
    
    def setup_plots(self):
        """Setup plot layout based on FFT visibility"""
        self.fig.clear()
        if self.show_fft.get():
            self.ax1, self.ax2 = self.fig.subplots(2, 1)
            self.fig.tight_layout(pad=1.5)
        else:
            self.ax1 = self.fig.add_subplot(111)
            self.ax2 = None
            self.fig.tight_layout(pad=1.5)
    
    def setup_plots_new_broken(self):
        """Setup plot layout based on FFT visibility"""
        self.fig.clear()
        if self.show_fft.get():
            self.ax1, self.ax2 = self.fig.subplots(2, 1, figsize=(10, 6))
            self.fig.tight_layout(pad=1.5)
        else:
            self.ax1 = self.fig.add_subplot(111)
            self.ax2 = None
            self.fig.tight_layout(pad=1.5)
        
        # Force a redraw to apply the layout changes
        if hasattr(self, 'canvas') and self.canvas:
            self.canvas.draw_idle()

    def toggle_fft(self):
        """Toggle FFT plot visibility"""
        self.setup_plots()
        self.update_plot()

def main():
    root = tk.Tk()
    app = WaveformGenerator(root)
    root.mainloop()

if __name__ == "__main__":
    main()